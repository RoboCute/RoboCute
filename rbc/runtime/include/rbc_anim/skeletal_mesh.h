#pragma once
#include "rbc_anim/bone_indices.h"
#include "rbc_anim/bone_container.h"
#include "rbc_anim/bone_pose.h"
#include "rbc_world/resources/skeleton.h"

namespace rbc {
struct AnimInstance;
struct AnimInstanceProxy;
struct AnimGraph;
struct AnimGraphResource;
struct SkeletalMesh;
struct BoneContainer;
struct SkinResource;
struct SkelMeshResource;
struct SkeletonResource;
struct SkeletalMeshRenderObject;
struct AnimRenderState;
struct ReferenceSkeleton;
}// namespace rbc

namespace rbc {

enum class EPreviousBoneTransformUpdateMode {
    None,
    UpdatePrevious,
    DuplicateCurrentToPrevious
};

enum class EBoneTransformUpdateMethod {
    AnimationUpdate,
    ClearMotionVector,
    ForceMotionVector
};

struct AnimationEvaluationContext {
    AnimInstance *anim_instance;
    SkeletalMesh *skel_mesh;
    // Evaluation Data, swaped when parallel eval
    luisa::vector<AnimFloat4x4> ComponentSpaceTransforms;
    luisa::vector<AnimSOATransform> BoneSpaceTransforms;
    luisa::vector<AnimFloat4x4> CachedComponentSpaceTransforms;
    luisa::vector<AnimSOATransform> CachedBoneSpaceTransforms;
    // flags
    bool bDoInterpolation;
    bool bDoEvaluation;

    void Init(AnimInstance *InInstance, SkeletalMesh *InSkelMesh) {
        anim_instance = InInstance;
        skel_mesh = InSkelMesh;
    }
    void Clear() {
        anim_instance = nullptr;
        skel_mesh = nullptr;
    }
};

// Object Wrapper for a skeleton with skinned mesh
// 和UE中的USkeletalMesh略有不同，这是整体实现控制SkeletalMesh的功能类
// Animation计算流程
// Skeleton Asset -> Rest Pose -> BoneSpaceTransforms
// Sampling Job:
//  Rest BoneSpaceTransform + time + AnimSequenceAsset (AnimSOATransform)
// --Evaluation (Sampling Job)-->
//  Runtime BoneSpaceTransform (AnimSOATransform)
// -- (Local To Model Job) -->
//  Runtime ComponentSpaceTransforms (AnimFloat4x4)
// --> CPU/GPU Skinning
//  ComponentSpace Triangles

struct RBC_RUNTIME_API SkeletalMesh {
public:
    // Entry For GameThread Loop
    void AllocateTransformData();
    void DeallocateTransformData();
    bool InitAnim();

    void Tick(float InDeltaTime_s);    // Tick entry for each system calls
    void TickPose(float InDeltaTime_s);// Tick Pose
    void TickAnimation(float InDeltaTime_s, bool bNeedsValidRootMotion);
    void TickAnimInstances(float InDeltaTime_s, bool bNeedsValidRootMotion);

    void PostInitMeshObject(SkeletalMeshRenderObject *) {}

public:
    // Entry for RenderThread Loop
    // void CreateRenderState_Concurrent(skr::RenderDevice *InRenderDevice);
    // void DoDeferredRenderUpdate_Concurrent(AnimRenderState &state);
    // void SendRenderDynamicData_Concurrent(AnimRenderState &state);
    // void DestroyRenderState_Concurrent();

public:// Core Task Interface
    void DispatchParallelEvaluationTasks();
    void ParallelAnimationEvaluation();
    void CompleteParallelAnimationEvaluation(bool bDoPostAnimEvaluation);

public:// Utilities
    void PerformAnimationProcessing(SkeletalMesh *InSkeletalMesh, AnimInstance *InAnimInstance, bool bInDoEvaluation, bool bForceRefPose, luisa::vector<AnimSOATransform> &OutBoneSpaceTransforms, luisa::vector<AnimFloat4x4> &OutComponentSpaceTransforms);
    void ComputeRequiredBones(luisa::vector<BoneIndexType> &OutRequiredBones, luisa::vector<BoneIndexType> &OutFillComponentSpaceTransformRequiredBones, int32_t LODIndex) const;

    /**
     * FillComponentSpaceTransforms
     * ==============================
     * 将Bone Local空间的Transform按照RefPose批量转换为Skeleton Model空间的Transform
     * 执行LocalToModel Task
     */
    void FillComponentSpaceTransforms(luisa::span<const AnimSOATransform> InBoneSpaceTransforms, luisa::span<const BoneIndexType> InFillComponentSpaceTransformsRequiredBones, luisa::vector<AnimFloat4x4> &OutComponentSpaceTransforms) const;

    void FlipEditableSpaceBases();
    // InitAnim Utility without checking resource

    void InitAnim_Internal();

    void SwapEvaluationContextBuffers();
    void ParallelUpdateAnimation();

    void ParallelDuplicateAndInterpolate();

    void RefreshBoneTransforms();
    void ResetToRefPose();
    void EvaluateAnimation(SkeletalMesh *InSkelMesh, AnimInstance *InAnimInstance, bool bInForceRefPose, CompactPose &OutPose) const;
    void EvaluatePostProcessMeshInstance();
    void RecalcRequiredBones(int32_t);
    void RecalcRequiredCurves();

    void PostAnimEvaluation();// share the same anim evaluation context

    /**
     * FinalizePoseEvaluationResult
     * ====================================================
     * Get output bone space transforms from final pose generated by AnimGraph execution
     */
    void FinalizePoseEvaluationResult(const SkeletalMesh *InSkelMesh, luisa::vector<AnimSOATransform> &OutBoneSpaceTransforms, CompactPose &InFinalPose);
    void FinalizeBoneTransforms();
    void FinalizeAnimationUpdate();

public:
    // helper
    void MarkRenderTransformDirty();
    void MarkRenderDynamicDataDirty();
    bool IsDynamicDataDirty() const;
    void EnableAnimation();
    void DisableAnimation();
    bool IsAnimationEnabled() const;
    bool ShouldBlendPhysicsBones();
    void SetUseGPUSkin(bool InSetUseGPUSkin) { bUseGPUSkin = InSetUseGPUSkin; }
    bool IsUseGPUSkin() const { return bUseGPUSkin; }
    bool IsInitialized() const { return bInitialized; }

public:
    // Get & Set
    const ReferenceSkeleton &GetRefSkeleton() { return ref_skeleton->ref_skel(); }
    const SkeletonResource &GetRefSkeletonResource() const { *ref_skin.get(); }
    SkinResource &GetSkinResource() { return *ref_skin.get(); }
    const SkinResource &GetSkinResource() const { return *ref_skin.get(); }
    SkelMeshResource &GetSkelMeshResource() { return *ref_skelmesh.get(); }
    const SkelMeshResource &GetSkelMeshResource() const { return *ref_skelmesh.get(); }

    int32_t GetPredictedLODLevel() const { return PredictedLODLevel; }
    luisa::vector<AnimFloat4x4> &GetEditableComponentSpaceTransforms();
    const luisa::vector<AnimFloat4x4> &GetComponentSpaceTransforms() const;
    size_t GetNumComponentSpaceTransforms() const;
    void SetBoneSpaceTransforms(luisa::span<const AnimSOATransform> InBoneSpaceTransforms);
    luisa::shared_ptr<BoneContainer> GetSharedRequiredBones();

public:
    // resources
    RC<SkeletonResource> ref_skeleton;
    RC<SkinResource> ref_skin;
    RC<SkelMeshResource> ref_skelmesh;

    RC<AnimInstance> anim_instance;
    luisa::shared_ptr<BoneContainer> shared_required_bones = nullptr;

    // Flags
    bool bNeedToFlipSpaceBaseBuffers = false;
    bool bDuplicateToCacheBones = false;
    bool bDoEvaluation = true;
    bool bRenderTransformDirty = false;
    bool bRenderDynamicDataDirty = false;
    bool bAnimationEnabled = false;
    bool bRequiredBonesUpToDate = false;
    bool bHasValidBoneTransform = false;
    bool bDoubleBufferedComponentSpaceTransforms = false;
    bool bForceMeshObjectUpdate = false;
    bool bUseGPUSkin = false;
    bool bInitialized = false;
    AnimationEvaluationContext anim_eval_context;
    luisa::vector<AnimFloat4x4> ComponentSpaceTransformsArray[2];

    int32_t CurrentEditableComponentTransformsIdx = 0;
    int32_t CurrentReadComponentTransformsIdx = 1;
    int32_t PredictedLODLevel = 0;// 当前占位，后续支持LOD
    luisa::vector<BoneIndexType> RequiredBones;
    luisa::vector<BoneIndexType> FillComponentSpaceTransformsRequiredBones;
    luisa::vector<AnimSOATransform> BoneSpaceTransforms;

private:
    // Object that is responsible for sending bone transforms
    SkeletalMeshRenderObject *render_object_ = nullptr;
    SkeletalMeshRenderObject *_previous_render_object = nullptr;// previous render object when RenderThread Recreated
};

}// namespace rbc